name: Release Automation

on:
  push:
    branches:
      - main

jobs:
  release:
    # Skip the workflow if the commit is made by GitHub Actions
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_TOKEN }}  # Use the PAT for checkout

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test

      - name: Generate release notes
        id: generate_release_notes
        run: |
          # Fetch all tags
          git fetch --tags

          # Check if any tags exist
          if git describe --tags --abbrev=0 > /dev/null 2>&1; then
            # If tags exist, get the latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0)
            RELEASE_NOTES=$(git log $LATEST_TAG..HEAD --oneline --pretty=format:"- %s")
          else
            # If no tags exist, generate release notes from the first commit
            RELEASE_NOTES=$(git log --oneline --pretty=format:"- %s")
          fi

          # Set the release notes as an output
          echo "::set-output name=notes::$RELEASE_NOTES"

      - name: Update README
        run: |
          echo "## Latest Release" >> README.md
          echo "**Version:** ${{ github.ref_name }}" >> README.md
          echo "**Release Notes:**" >> README.md
          echo "${{ steps.generate_release_notes.outputs.notes }}" >> README.md

      - name: Commit updated README
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add README.md
          git commit -m "Update README for release ${{ github.ref_name }} [skip ci]"
          git push https://${{ secrets.REPO_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main


      - name: Generate Tag
          id: generate_tag
          run: |
            git fetch --tags
  
            # Check if any tags exist
            if git describe --tags --abbrev=0 > /dev/null 2>&1; then
              LATEST_TAG=$(git describe --tags --abbrev=0)
              IFS='.' read -r MAJOR MINOR PATCH <<< "${LATEST_TAG//v/}"
              PATCH=$((PATCH + 1))
              NEW_TAG="v$MAJOR.$MINOR.$PATCH"
            else
              NEW_TAG="v1.0.0"
            fi
  
            echo "New Tag: $NEW_TAG"
  
            # Check if tag already exists (to avoid conflicts)
            if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
              echo "Tag $NEW_TAG already exists. Incrementing..."
              NEW_TAG="v$MAJOR.$MINOR.$((PATCH + 1))"
            fi
  
            git tag $NEW_TAG
            git push https://${{ secrets.REPO_TOKEN }}@github.com/${{ github.repository }}.git $NEW_TAG
  
            echo "::set-output name=new_tag::$NEW_TAG"
  

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_TOKEN }}
        with:
          tag_name: ${{ steps.generate_tag.outputs.new_tag }}  # Use the generated tag
          release_name: Release ${{ steps.generate_tag.outputs.new_tag }}
          body: ${{ steps.generate_release_notes.outputs.notes }}
          draft: false
          prerelease: false

    #   - name: Notify Slack
    #     uses: slackapi/slack-github-action@v1
    #     with:
    #       slack-message: "ðŸš€ New Release: ${{ steps.generate_tag.outputs.new_tag }} has been published!\n\nRelease Notes:\n${{ steps.generate_release_notes.outputs.notes }}"
    #     env:
    #       SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}